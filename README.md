# Java-Threads
## Sleeping Barber Problem
The sleeping barber problem is a classic inter process communication and synchronization problem between multiple operating system processes. The design strategies used are analogous to that of keeping a barber working when there are customers and resting when there are none. The analogy used  is a hypothetical barber shop with 2 barbers with customers limiting to 20. The barber has 2 barber chairs and a wating room with 3 chairs in it. 

When customer arrives at the shop, he first checks if any barbers are available only after which he sits in the chair for the haircut. If the customer finds that the barber is busy in cutting hair then the customer goes into waiting room and acquires an empty seat. If there is a free chair in the waiting room then the customer sits in it and waits for his turn. If there are no free chairs then the customer leaves the shop. When barber finishes with cutting his customerâ€™s hair, he then goes to the waiting room to see if there are other customers waiting. If there are any customers in the queue, they get assigned to the available barber and if there are no customers he returns to his chair and goes to sleep.

The above description ensures that the shop functions correctly with the barber cutting the hair of customers until there are no more customers waiting in the queue for their haircuts. To achieve this goal I have used the concept of Reentrant locks which implements the lock interface and provides synchronisation to methods while accessing shared resources. I have used Reentrant lock for barbers and chairs as these are the two resources which are being used by the customer to get their haircuts done without starving for their turn. Main reason for choosing Reentrant locks is to allow the threads to acquire the locks on a resource more than once. By this way the barber thread is having a lock while serving the customers one at a time thereby not allowing the customer thread to access it. 

